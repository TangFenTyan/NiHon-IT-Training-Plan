# JAVA

## (01)Java介绍

### JDK & JRE
* **JRE**：Java Runtime Environment （Java 运行时环境）
  * JRE包括Java虚拟机（Java Virtual Machine，JVM），以及 Java 平台核心类和基础 Java 平台库；通过 JVM 才能在电脑系统执行 Java 应用程序（Java Application）
* **JDK**：Java Development Kit （Java 开发工具包）
  * JDK 是 JRE 的超集，包含 JRE 的所有内容，以及开发小程序和应用程序所需的工具，例如编译器和调试器

### 自动垃圾回收（Garbage Collection）
* Java中对象的创建和放置都是在存储器堆栈上面进行
* 当一个对象没有任何引用的时候，Java的自动垃圾收集机制就发挥作用，自动删除这个对象所占用的空间，释放存储器以避免存储器泄漏
* 而在常规语言例如C++，程序员必须确保已分配的内存被释放。防止造成内存泄漏的麻烦
* 不同厂商、不同版本的JVM中的存储器垃圾回收机制并不完全一样，通常越新版本的存储器回收机制越快

## (03)Java HelloWorld

### HelloWorld
```java
public class HelloWorld {
    public static void main(String[] args) {
        System.out.println("Hello World!");
    }
}
```
> public：表示这个类是公开的 \
> class：表示类的意思 \
  > public 和 class 是 Java 中的关键字须小写 \
> HelloWorld：表示类名 \
  > 注意:文件名须与类名同名(区分大小写),通常类名以大写字母开头 \
> {}中的内容为类的定义 \
> main方法：Java 程序的固定入口方法 \
  > public：表示方法是公开的 \
  > static：表示方法是静态的 \
  > void：表示方法的返回类型为void \
  > String[]：表示参数的类型 \
  > args：表示参数的名称 \

## (04)Java 注释

### 注释
* 文档注释和多行注释的作用基本相同，唯一的区别是文档注释可以使用javadoc命令生成文档
```java
/**
  *文档注释
*/
```

### 生成JavaDoc
* Tool-Generate JavaDoc-Output directory-Command line arguments: "-encoding UTF-8"-Generate

## (05)Java 标识符
* Java语言中，对于变量，常量，函数，语句块也有名字，我们统统称之为Java标识符，通常由字母和数字以及其它字符构成

### 标识符规范
* 标识符可以以字母[A-Za-z]，美元符号$或下划线_开始
* 首字母后可以是字母、数字、下划线的任意组合
* Java关键字不能当作Java标识符

### 标识符命名约定
* **类和接口名**，首字母大写，如果是俩个单词，第二个单词的首字母大写
* **方法与变量**，首字符小写，其余的首字母大写，含大小写。尽量少用下划线。例如myName
* **常量**，全部字母大写，如果是俩个单词，使用下划线分隔，例如SIZE_NAME

## (06)Java 关键字与保留字

### 关键字
* Java语言中，关键字是特殊意义的固定单词
  * **数据类型**：boolean、int、long、short、byte、float、double、char、class、interface。
  * **流程控制**：if、else、do、while、for、switch、case、default、break、continue、return、try、catch、finally。
  * **修饰符**：public、protected、private、final、void、static、strict、abstract、transient、synchronized、volatile、native。
  * **动作**：package、import、throw、throws、extends、implements、this、supper、instanceof、new

### 保留字
* 保留字是为 Java 预留的关键字，它们虽然现在没有作为关键字。但可能在未来的版本中，将其作为关键字
  * true、false、null、goto、const。

## (07)Java 变量与常量

### 变量
* 变量可以分为三类：**局部变量**、**成员变量（实例变量）**、**静态变量（类变量）**
* 变量是程序中最基本的存储单元,由变量类型,变量名和存储的值组成。
* Java是一种**强类型**语言 ,每个变量都必须声明其数据类型。
* **强类型**：强制数据类型定义，更加严谨安全。所有的变量必须先声明、后使用。指定类型的变量只能接受类型与之匹配的值
#### 局部变量
* 局部变量位于方法或语句块内部，并且仅在声明的方法，语句块中可见
* 程序进入方法、语句块时会创建局部变量，直到执行完方法，语句块时，变量就会消失
* 局部变量没有任何关键字修饰
```
数据类型 标识符;
OR
数据类型 标识符 = 值;
```
#### 成员变量（实例变量）
* 成员变量是指在类体的变量部分中定义的变量，也称为属性，用于存储对象的状态
* 成员变量声明在类的内部，方法外部，对象创建时成员变量也跟着创建，对象消失成员变量也跟着消失
```java
public class HelloWorld {
    //成员变量
    public String name;
    public int age;
}
```
#### 静态变量（类变量）
* 静态变量在类中使用static关键字定义，在方法，语句块之外。
* static 修饰符告诉编译器，无论类被实例化多少次，类变量始终只有一个变量副本。只要类被加载到内存中，它就会存在。
* 随着程序启动时会创建静态变量，程序停止时会销毁静态变量。
```java
public class HelloWorld {
    //静态变量
    public static String name = "zhangsan";;
    public static int age = 18;
}
```

### 常量
* 常量是指在程序的整个运行过程中值保持不变的量，也可以分为三类：**局部常量**、**成员常量（实例变量）**、**静态常量（类变量）**
```java
// final 数据类型 标识符 = 值;
public class HelloWorld {
    //静态常量
    public static final String name = "zhangsan";;
    //成员常量
    final int age = 18;
    public static void main(String[] args) {
        // 局部常量
        final boolean i = true;
    }
}
```

## (08)Java 基本数据类型
* 整数类型、浮点类型、布尔类型、字符类型

### 整数类型
* **字节型byte**类型是最小的整数类型。当用户从网络或文件中处理数据流时，或者处理可能与 Java 的其他内置类型不直接兼容的未加工的二进制数据时，该类型非常有用。
* **短整型short**类型。
* **整型int**类型，常用的一种整数类型。
* **长整型long**：对于超出 int 类型所表示的范围时就要使用 long 类型


### 浮点类型
* 浮点类型是带有小数部分的数据类型，也叫**实型**.浮点型数据包括**单精度浮点型（float）**和**双精度浮点型（double）**。
* 双精度类型 double 比单精度类型 float 具有更高的精度和更大的表示范围。
* 注意：单精度类型float的值必须要以大写字母 F 或小写字母 f 结尾，否则会被当作 double 值。

### 布尔类型
* true 和 false

### 字符类型
* 字符类型（char）表示一个字符。可表示标准的 ASCII 码或 Unicode 字符

## (09)Java 运算符

### 运算符
* 算术运算符
  * 一元运算符
    * `-`: 取反符号
  * 二元运算符
* 赋值运算符
* 逻辑运算符
  > `&&`: 短路与(左边为false则不再执行右边) \
  > `||`: 短路或(左边为true则不再执行右边) \
  > `!`: 逻辑非 \
  > `&`: 逻辑与 \
  > `|`: 逻辑或 \
* 关系运算符
* 位运算符
  * 直接对整数类型的位进行操作，这些整数类型包括 long，int，short，char 和 byte。主要用来对操作数二进制的位进行运算。
  > `&`: 按位进行与运算 \
  > `|`: 按位进行或运算 \
  > `^`: 按位进行异或运算 \
  > `~`: 按位进行取反运算 \
  > `>>`: 有符号右移移运算符 \
  > `<<`: 左移位运算符 \
  > `>>>`: 无符号右移运算符 \
* 补充
  * 三元运算符
  * instanceof: 判断其左边对象是否为其右边类的实例，返回boolean类型的数据。可以用来判断继承中的子类的实例是否为父类的实现。
    ```
    boolean b = (任意对象表达式) instanceof (任意已定义的对象类)
    ```

### 

## (10)Java 运算符优先级
| 优先级 | 运算符 | 关联性 |
|------|-----------------|--------|
| 优先级 | 运算符 | 关联性 |
| 1 | ()、[]、{} | 左到右 |
| 2 | !、-、~、++、-- | 右到左 |
| 3 | *、/、% | 左到右 |
| 4 | +、- | 左到右 |
| 5 | <<、>>、>>>  | 左到右 |
| 6 | <、<=、>、>=、instanceof | 左到右 |
| 7 | ==、!=  | 左到右 |
| 8 | &  | 左到右 |
| 9 | ^  | 左到右 |
| 10 | &#124;  | 左到右 |
| 11 | &&  | 左到右 |
| 12 | &#124;&#124;  | 左到右 |
| 13 | ?: | 右到左 |
| 14 | =、+=、-=、*=、/=  | 右到左 |

## (12)Java 循环

### 循环中断
* `break`：break 用于完全结束一个循环
* `continue`：continue用于跳过循环中剩余的语句而强制执行下一次循环

## (13)Java 字符串与字符串常用方法
* Java字符串属于引用数据类型
* 字符串是由零个或多个字符组成的有限序列

### 字符串定义
* 双引号定义字符串
```
String a = "yes";
```

* 文本块：使用三引号定义一个多行字符串(Java 13 提供的预览特性)
```
String a = """
  Hello
  World
  """;
```

* String 类定义字符串
```
String a = new String("Hello World");
```
### 字符串常用方法
* **字符串拼接**：加法运算符可以将多个字符串进行拼接
* **获取字符串长度**：使用String 类的 `length()`方法可以获取字符串长度
* **截取字符串**：使用String 类的 `substring()`方法可以截取字符串
* **去除首尾空格**：使用String 类的 `trim()`方法可以去除首尾空格
* **字符串替换**：使用String 类的 `replace()`方法可以进行字符串替换
* **根据字符查找字符所在字符串索引**：使用String 类的 `indexOf()`方法和 `lastlndexOf()` 方法可以根据字符查找字符所在字符串索引，`indexOf()`方法为首次出现的索引位置，`lastlndexOf()`方法为最后出现的索引位置

## (14)Java 一维数组
* 数组属于引用数据类型

### 一维数组定义
* 数组中的数据类型可以是基本数据类型和引用数据类型。
* 数组的大小一旦声明就不能再修改
```java
数据类型[] 数组名;
int[] arrayName;
数组名 = new 数据类型[数组长度];
arrayName = new int[5];
OR
数据类型 数组名[];
int arrayName[];
数组名 = new 数据类型[数组长度];
arrayName = new int[5];
OR 简写
数据类型[] 数组名 = new 数据类型[数组长度];
int[] arrayName = new int[5];
```
### 一维数组初始化
* 定义的同时进行数组赋值
  ```java
  数据类型[] 数组名 = {元素1, 元素2, 元素3, 元素n};
  int[] arrayName = {1, 2, 3, 4, 5};
  OR
  数据类型[] 数组名 = new 数据类型[]{元素1, 元素2, 元素3, 元素n};
  int[] arrayName = new int[]{1, 2, 3, 4, 5};
  ```
* 定义后再进行数组赋值
  ```java
  int[] arrayName = new int[5];
  arrayName[0] = 1;
  arrayName[1] = 2;
  arrayName[2] = 3;
  arrayName[3] = 4;
  arrayName[4] = 5;
  ```

### 一维数组取值
* 使用foreach 循环遍历数组
```java
for (int i : arrayName) {
  System.out.println(i);
}
```

## (15)Java 二维数组

### 二维数组定义
* 每个数组元素是一个一维数组
* 数组长度2可为空，表示可变化
```java
数据类型[][] 数组名;
int[][] arrayName;
数组名 = new 数据类型[数组长度1][数组长度2];
arrayName = new int[5][];
OR
数据类型 数组名[][];
int arrayName[][];
数组名 = new 数据类型[数组长度1][数组长度2];
arrayName = new int[5][];
OR
数据类型[][] 数组名 = new 数据类型[数组长度1][数组长度2];
int[][] arrayName = new int[5][];
```

### 二维数组初始化
* 定义的同时进行数组赋值
  ```java
  数据类型[][] 数组名 = {{xx,xx}, {}, {}, {}};
  int[][] arrayName = {{1,2}, {3,4}, {5}};
  OR
  数据类型[][] 数组名 = new 数据类型[][]{{xx,xx}, {}, {}, {}};
  int[][] arrayName = new int[][]{{1,2}, {3,4}, {5}};
  ```
* 定义后再进行数组赋值
  ```java
  int[][] arrayName = new int[3][2];
  arrayName[0][0] = 1;
  arrayName[0][1] = 2;
  arrayName[1][0] = 3;
  arrayName[1][1] = 4;
  arrayName[2][0] = 5;
  ```

### 二维数组取值
* 使用foreach 循环遍历数组
```java
for (int[] ints : arrayName) {
  for (int anInt : ints) {
    System.out.println(anInt);
  }
}
```
* `Arrays.deepToString`
```java
System.out.println(Arrays.deepToString(arrayName))
```

## (16)Java 面向对象概念

### 对象特点
* 对象具有属性和行为
* 对象具有变化的状态
* 对象具有唯一性
* 对象都是某个类别的实例

### 面向对象核心特性
* 封装
  * 利用抽象数据类型将数据和基于数据的操作封装在一起，使其构成一个不可分割的独立实体。
  * 数据被保护在抽象数据类型的内部，尽可能地隐藏内部的细节，只保留一些对外接口使之与外部发生联系。
  * 用户无需知道对象内部的细节，但可通过对象对外提供的接口来访问该对象。
  * 保证了程序和数据都不受外部干扰而且不被误用。
* 继承
  * 类之间的一种关系，子类可以拥有父类的全部特征和行为。
* 多态
  * 在父类中定义的属性和方法被子类继承后，可以具有不同的属性或表现方式。
  * 简单说就是子类可以自行实现功能扩展，而不需要修改基于父类的代码。

## (17)Java 类与对象

### 类定义
* 在面向对象中，类和对象是最基本、最重要的组成单元。
* 类是概念模型，定义对象的所有特性和所需的操作，对象是真实的模型，是一个具体的实体。
* 简单理解就是类是一个模板，可用来生产对象，而对象是一个具体的事物。
* Java 中类是引用数据类型

### 类的访问修饰符
| 访问修饰符 | 可修饰 | 可访问 |
|------|------|------|
| public | 类、属性、方法 | 任何 |
| private | 内部类、属性、方法 | 同一类 |
| protected | 内部类、属性、方法 | 同一包和子类 |
| default | 默认修饰符 | 同一包 |

### 类创建对象
* 使用 new 关键字可以实例化对象。首先在内存的栈空间中声明对象。之后在内存的堆空间实例化对象。
```java
类名 对象名称 = new 类名();
```
* 使用getDeclaredConstructor方法获得构造器对象并调用newInstance()方法创建对象
```java
类名 对象名称 = 类名.class.getDeclaredConstructor().newInstance();
```
* 使用Class.forName方法获得类的class并调用newInstance()方法创建对象
```java
类名 对象名称 = (类名) Class.forName("类名").newInstance();
```

## (18)Java 方法

### 方法定义
* 完整的方法通常包括**方法名称**、**方法主体**、**方法参数**和**方法返回值**类型
```java
访问修饰符 返回类型 方法名(参数列表) {
    //语句块
    //如有返回值做return操作
}
```
* 访问修饰符可取：
  * public、private、protected、或省略。
  * 同样方法也可被final、abstract、static等修饰。
* 返回类型：
  * 任何数据类型或 void(无返回值)。

### 方法传值接值
* 方法接收**基本类型参数**时，方法外部和方法内部的变量**互不影响**。
* 方法接收**引用数据类型参数**时，方法外部和方法内部的变量**可相互影响**(虽然String是引用数据类型，但是String一旦赋值无法修改)。

### 可变参数
* 方法参数个数不确定时，可使用可变参数方式。
* 可变参数用 **类型…**​ 表示，可变参数可简单理解为数组类型

## (19)Java 构造方法

### 构造方法
* 构造方法是一个特殊方法，用来初始化类的一个新对象。
* 每个类都有一个默认的构造方法，创建对象之后会自动调用。
* 可以有多个构造方法。
* 方法名必须与类名相同。
* 构造方法不能被static、final、abstract等修饰符修饰。
* 不需要写返回值字段。
* 类中定义了一个或多个构造方法的话 Java 不会再提供默认构造方法。

### this 关键字
* 这里的this关键字用于实例方法指向当前对象。
* 解决实例变量与构造方法参数同名称时，不能赋值的问题。
* 同时this 关键字也还能调用同一类中其他的成员方法。
```java
void change() {
    System.out.println("change");
}
void eat(){
    this.change();
}
```
* 注意：静态成员不能直接访问非静态成员，也就是说static修饰的方法不能使用this。

## (20)Java 方法重载

### 方法重载
* 同一个类中多个同名方法，同名方法的形参列表不同。可避免类似方法，出现太多方法名的情况，同时调用简单。

## (21)Java 类封装

### 封装的优点
* 隐藏实现细节：对象的内部实现被隐藏，只向外部提供一个访问接口，可以减少代码的耦合度，并提高代码的可维护性和可扩展性。
* 简化编程：封装使得对象的使用者可以更加简单和方便地使用对象，不需要了解对象的复杂实现，也不需要知道对象内部的状态和数据结构。
* 提高安全性：封装可以保护对象的属性和方法不被外部直接访问和修改，确保对象的数据安全性和正确性。
* 提高代码的可重用性：封装使得对象可以被多次使用，并且在不同的环境中被重复使用，提高了代码的可重用性。

### 封装的步骤
* 属性的可见性设置为 private。
* 每个属性创建对应的setter方法和getter方法，可见性设置为 public。
* 在setter方法和getter方法中，需对属性值的合法性进行判断。

## (22)Java 继承

### 继承
* 需注意过度的继承也会导致代码的耦合性增加，因此需谨慎使用继承，避免出现继承层次过深和复杂的情况。
* 父类有有参的构造方法但没有无参构造方法的情况，那么在子类中必须有有参构造方法，因为子类如不提供构造方法的话会调用父类中无参的构造方法。
* Java的继承是单一继承，一个子类只能拥有一个父类，一个父类可以拥有多个子类。
```java
访问修饰符 class 类名 extends 父类 {
}
```

## (23)Java super关键字

### super
* super用在子类中，可以访问父类变量或方法。
* super和this一样不能在static 变量、static 方法和 static 代码块中使用。
* 调用super()必须写在子类构造方法的第一行。
* 子类的构造方法会隐含地调用super()(不用显式的写也行)，如父类没有这种形式的构造函数，则报错。

### super用法
* `super.父类属性`：调用父类中的属性
* `super.父类方法`：调用父类中的方法
* `super()`：调用父类的无参构造方法
* `super(参数)`：调用父类的有参构造方法

## (24)Java 方法重写

### 方法重写
* Java中的方法重写(Override)指的是在子类中重新定义一个与父类中同名、同返回类型、同参数列表的方法。
* 并且方法的访问修饰符不能低于父类中的方法。
* 构造方法不能被重写。
* 重写方法一定不能抛出新的检査异常或者比被重写方法更加宽泛的检査型异常。
* 只有父类被子类继承时，方法才能被重写。
* 定义为 static 的方法不能被重写，但是能够再次声明。
* 定义为 final 的方法不能被重写。
* 子类和父类在同一个包中时，子类可以重写父类的所有方法，除了定义为 private 和 final 的方法。
* 子类和父类不在同一个包中时，子类只能重写父类的定义为 public 和 protected 的非 final 方法。

### 方法重写的优点
* 提高代码的可维护性：方法重写可以让子类根据自身的特点重新定义某些继承自父类的方法，使得代码更加灵活，容易维护。
* 实现多态性：方法重写是实现多态性的重要机制，可以在运行时动态地调用子类对象的方法，从而根据不同对象的类型执行不同的操作。

### 与方法重载的区别
* 参数列表不同：方法重载的方法名相同，但是参数列表不同（参数类型、参数个数、参数顺序等），方法重写的方法名和参数列表都必须相同。
* 返回值不同：方法重载可以改变返回值类型，但是方法重写的返回值类型必须和被重写的方法返回值类型相同或是其子类。
* 静态/实例方法：方法重载可以是静态方法或实例方法，方法重写只能是实例方法。
* 修饰符：方法重载可以改变方法的修饰符，但是方法重写的访问修饰符不能低于父类中的方法。
* 抛出异常不同：方法重载的方法可以抛出任何非受查异常，而方法重写的方法只能抛出和被重写方法抛出异常相同或是其子类。

## (25)Java final关键字

### final关键字用法
* final关键字用来表示不可变的、不可修改的意思。
* **变量**：用final修饰的变量表示一个常量，即只能赋值一次且在声明时或构造函数中进行赋值，之后不可修改。
* **方法**：用final修饰的方法表示该方法不可被重写。如果一个类中的某个方法不希望在子类中被修改，可以使用final关键字修饰该方法。
* **类**：用final修饰的类表示该类不能被继承。如果一个类不希望被其他类继承，可以使用final关键字修饰该类。

### final关键字的好处
* 提高程序的性能：Java 编译器可以使用一些优化技术，例如内联方法，以便更好地处理 final 变量。
* 更安全的多线程编程：final 变量在多线程环境中是线程安全的，因为其值不会被更改，避免了线程竞争和同步的问题。
* 更加可读的代码：final 关键字可以让代码更加易于理解和维护，因为它明确了某些值或行为的不可更改性。

## (26)Java 多态

### 多态
* Java中多态是一种对象的行为，指的是同一个方法名，但具体的实现方式却有多种可能。
* 这种能力称为"多态性"，Java中的多态性分为编译时多态性和运行时多态性两种。
**编译时多态性**
* 编译时多态性也称为静态多态性，指的是方法的重载特性，即在编译时确定调用的方法。
**运行时多态性**
* 运行时多态性也称为动态多态性，指的是方法的重写特性，即在运行时根据对象的实际类型确定调用的方法。
* 运行时多态性需要满足三个条件：继承、方法重写和父类引用指向子类对象(向上转型)。

### 多态的优点
* 可扩展性：多态使得程序的扩展变得更加容易。通过继承和方法重写，可以轻松地添加新的功能，而无需对现有代码进行修改。
* 代码重用：多态性使得代码的重用更加容易。可以创建一个通用的父类，然后通过继承该父类创建许多不同的子类。这些子类可以共享通用的属性和方法，从而实现代码重用。
* 灵活性：多态性使得程序更加灵活。通过多态，可以在运行时决定对象的类型，并动态地调用相应的方法。这使得程序的行为可以根据运行时环境的变化而变化，从而使程序更加适应不同的场景。

## (27)Java 抽象类

### 抽象类
* Java中的抽象类是一种特殊的类，它不能被实例化，只能被继承。
* 抽象类定义了一组抽象方法，这些方法没有实现，只有方法声明。
* 子类必须实现这些抽象方法才能被实例化。

### 抽象类的优点
* 抽象类可以为具有相似特征的一组类提供一个通用的抽象概念，避免了代码的重复，提高了代码的复用性和可维护性。
* 抽象类可以限制某些方法的访问权限，从而控制子类对其行为的修改，提高了程序的安全性。
* 抽象类可以通过定义抽象方法来规范子类的行为，增强了程序的可扩展性。子类必须实现抽象方法，以保证其符合规范。

### 抽象方法
* 抽象方法是指只有方法声明而没有方法实现的方法。
* 使用 abstract 关键字进行修饰。
* 抽象方法必须在抽象类中声明。

### 抽象注意事项
* 抽象方法不能被声明为私有、静态、final或native。
* 抽象类可以包含抽象方法和具体实现的方法。
* 抽象类不能实例化。
* 子类继承抽象类时必须实现父类的所有抽象方法，否则子类也必须被声明为抽象类。

## (28)Java 接口

### 接口
* Java中的接口（Interface）是一种特殊的抽象类。
* 它是一组抽象方法的集合，不包含属性，所有方法必须是公共的抽象方法。
* 实现接口的类必须实现接口中所有的方法。接口可以看作是一种约定，用于规范某一类对象必须具备的行为。

### 接口定义
* 接口可以有多个父接口。
* 接口只能继承接口，不能继承类。
  ```java
  访问修饰符 interface 接口名 [extends 接口名(可多个)] {
  }
  ```

### 接口实现
* 一个类可以实现一个或多个接口。
* 如有extends 那么implements须放在extends后。
  ```java
  访问修饰符 class 类名 [extends 类(只一个)] [implements 接口名(可多个)] {
  }
  ```

### 接口的优点
* 规范行为：接口可以规范某一类对象必须具备的行为。
* 多重继承：Java中的类只能单继承，但一个类可以实现多个接口，这样就可以实现多重继承，提高了代码的复用性和灵活性。
* 松耦合：接口使得类与类之间的依赖关系更加松耦合，便于代码的维护和升级。
* 扩展性：接口定义了一组规范，可以方便地进行扩展和升级。如果需要添加新的行为，只需新增一个实现了接口的类即可，不需要修改已有的代码。

### 接口补充
* 从 JDK 1.8 开始，Java 接口可以定义**默认方法**和**静态方法**。
* **默认方法**是在接口中已经有了一个默认的实现方法，实现类可以直接继承或者重写这个方法，而不需要再次实现。
* **静态方法**是指在接口中定义的静态方法，可以通过接口名直接调用，而不需要实现类的实例。

## (29)Java 抽象类与接口区别

### 抽象类与接口区别
* **实现**：一个类只能继承一个类，但是可以实现多个接口。接口的实现使用关键字 implements，而抽象类的实现使用关键字 extends。
* **构造函数**：抽象类可以有构造函数，而接口不能有构造函数。
* **成员变量**：接口中定义的变量默认为 public static final，也就是常量，而抽象类中定义的变量则可以是各种类型的变量。
* **成员方法**：接口中的方法默认为 public abstract，而抽象类中的方法可以有不同的访问修饰符，并且可以有非抽象方法。
* **多重继承**：由于一个类只能继承一个类，而可以实现多个接口，因此接口可以用来实现多重继承。
* 接口更适用于定义类之间的行为规范，而抽象类更适用于将公共功能放在一起，以便子类继承和重用。

## (30)Java static关键字

### static关键字
Java中static关键字用于指示一个成员变量或方法属于类本身，而不是属于类的实例。
使用static关键字定义的变量或方法可以通过类名直接访问，而不需要创建类的实例。

### static优点
* 节省内存：static变量只会在内存中存在一份拷贝，而不是每个实例都有一份拷贝，这可以节省内存空间。
* 方便访问：由于static方法和变量可以直接使用类名调用，所以可以更方便地访问这些成员，而不需要创建类的实例。
* 可以共享数据：static变量可以在所有实例之间共享，这样可以在多个实例之间共享数据，提高了程序的效率。
* 方便实现工具类和单例模式：使用static方法和变量可以方便地实现工具类和单例模式，因为这些类通常不需要创建实例，而是直接使用类名调用方法或变量。

### static关键字使用
* 静态变量
  * 静态变量只分配一次内存，在加载类的过程中完成静态变量的内存分配。
  * 静态变量被类的所有实例共享。
    ```java
    public static int count = 0;
    ```
* 静态方法
  * 静态方法可通过类名直接调用。
    ```java
    public static int getCount() {
        return count;
    }
    ```
* 静态代码块
  * 静态代码块用于初始化类，为类的静态变量赋初始值。
  * 静态代码块可多个并放在类中的任何地方，在加载类时执行静态代码块。
  * 静态代码块只会被执行一次。
    ```java
    static {
        System.out.println("类加载了");
    }
    ```

## (31)Java 内部类

### 内部类
* Java中的内部类是定义在一个类中的类。
* 内部类可分为四种：成员内部类、静态内部类、方法内部类和匿名内部类。

### 成员内部类
* 成员内部类是一种定义在类中的内部类，它与外部类的成员变量和方法处于同一层次。
* 成员内部类可以访问外部类的成员变量和方法，即使这些成员变量和方法是私有的。
```java
class OuterClass {
  // 外部类
  class InnerClass {
    // 内部类
  }
}
```
* 成员内部类优点：
  * 可以访问外部类的私有成员变量和方法，从而可以提供更加严密的封装性。
  * 可以用来实现一些只在外部类中使用的接口，从而提高代码的模块化程度。

### 静态内部类
* 静态内部类是定义在一个类内部，并使用 static 修饰的类。
* 相对于成员内部类，它与外部类的实例无关，也就是说可以不依赖于外部类的实例而直接创建对象。
* 在静态内部类中可以定义静态成员变量、静态方法、实例变量、实例方法等，与普通的类类似。
```java
class OuterClass {
    static class StaticInnerClass {
        // 静态内部类
    }
}
```
* 静态内部类优点：
  * 可以访问外部类的静态变量和方法，方便地共享数据和方法。
  * 可以直接创建静态内部类的对象，而不需要先创建外部类的对象。

### 方法内部类
* 方法内部类是指定义在一个方法内部的类。
* 只能在该方法内部被访问，无法从方法外部访问。
* 还需注意不能使用访问修饰符。
```java
class OuterClass {
    public void method() {
        class MethodInnerClass {
            // 方法内部类
        }
    }
}
```
* 方法内部类通常用于需要临时创建一个类的情况，且这个类只需要在该方法中使用。
* 相比于定义一个独立的类，使用方法内部类可以减少类的数量，避免命名冲突，提高代码的可读性和可维护性。

### 匿名内部类
* 匿名内部类是一种没有命名的内部类。
* 它可以用于创建只需要使用一次的简单类。
* 通常情况下，它用于实现接口或继承类。
* 匿名内部类可使代码更加简洁、灵活和实用。

## (32)Java 异常

### 异常
* Java 异常是指在程序执行过程中发生的一些不期望的、异常的事件，例如除数为 0、空指针引用等。
* 当这些异常事件发生时，程序会停止执行并抛出异常，如果异常没有得到处理，程序可能会终止运行。
* Java 中提供了异常处理机制，可以让程序在发生异常时执行相应的处理逻辑，避免程序崩溃。
* Exception通常表示可预见的问题，例如输入错误、网络中断、文件不存在等等，这些异常可以通过代码进行处理。

### 异常类型
* Java中所有异常类型都是内置类java.lang.Throwable类的子类，即Throwable类是所有异常和错误的父类。
* Throwable类下有两个异常分支 Exception 和 Error。
* Exception包括 Unchecked Exception（非检查异常）和 Checked Exception（检查异常）两大类别。
  * 非检查异常是编译器不要求强制处理的异常，也就是说编写代码时不去处理此类异常，程序还是会编译通过。非检查异常不需要在代码中显式处理，例如NullPointerException(空指针异常)、IllegalArgumentException(非法实参调用方法)等。
  * 检查异常是编译器要求必须处理的异常，也就是说编写代码时必须处理此类异常，否则程序无法编译通过。检查异常必须在代码中显式处理，否则编译器会报错，例如IOException(IO操作异常)、SQLException(SQL异常)等。
* Error是指不希望被应用程序捕获的严重问题，这些错误在应用程序的控制和处理能力之外。

## (33)Java 异常处理

### 异常处理机制
* **捕获异常**：用try catch 语句捕获并处理异常。
* **抛出异常**：抛出异常是Java中一个程序处理的动作，如当前方法没有捕获异常，异常会抛到上层调用方法，直到被捕获为止。

### 捕获异常
* Java中通常采用try catch 语句来捕获异常并处理。
``` java
try {
    // 可能发生异常的语句
} catch (异常类型 e) {
    // 捕获并处理try抛出的异常
} finally {
    // 无论是否发生异常都会执行的语句
}
```
* catch语句可以有多个，代表代码块中可能有很多语句会发生异常。
* 注意：当捕获的多个异常类之间存在父子关系时，捕获异常时一般先捕获子类，再捕获父类。所以子类异常必须在父类异常的前面。
* 因为catch是按照从上往下的顺序进行匹配，一旦匹配就不会再向下继续匹配。
``` java
try {
    int i = 1 / 0;
}catch (Exception e){
    e.printStackTrace();//输出异常信息
}finally {
    System.out.println("Done");
}
```

### 抛出异常
* Java中throw 语句用来直接拋出一个异常，后接一个可拋出的异常类对象。
``` java
// throw 异常类对象;
int b = 0;
if (b == 0) throw new ArithmeticException();
int i = 1 / b;
```
* 这里先判断除数的值，如为零则使用throw语句抛出算数异常类对象。
* 可使用throw语句抛出任何类型的Throwable类或其子类的对象，会中断执行，也就是说throw语句之后的内容不会执行。

### 声明异常
* Java中throws语句可声明方法要抛出何种类型的异常。
* 用于方法可能出现异常，但不处理此异常时，可通过throws语句声明异常。
``` java
// throws 异常类对象1,异常类对象2;
public static void main(String[] args) throws ArithmeticException{
}
```

### throws和throw的区别：
* throws用于在方法声明中指定可能会抛出的异常类型，表示一种可能性，但并不一定会发生这些异常。
* throw则是用于在代码中显式抛出异常，表示一定抛出某种异常。

## (34)Java 自定义异常

### 自定义异常优点
* 该类继承自Java的标准异常类（Exception、RuntimeException等）之一。
* 提高代码的可读性和可维护性：通过自定义异常类，我们可以将程序中可能发生的不同异常情况进行分类，并为每种情况定义一个特定的异常类。这样，我们就可以更清晰地了解程序中可能发生的错误，并更好地维护代码。
* 提供更精确的异常信息：Java的标准异常类提供了一些常用的异常类型，如NullPointerException等。但是，在某些情况下，这些异常类型可能无法满足我们的需求。通过自定义异常类，我们可以提供更加精确和具体的异常信息，这样我们就可以更好地定位和解决程序中的错误。
* 程序结构更清晰：通过自定义异常类，我们可以将异常处理与业务逻辑分离。这样，我们就可以更好地管理代码，并使程序结构更加清晰。
* 提高代码的健壮性：通过自定义异常类，我们可以更好地处理程序中的异常情况，从而提高程序的健壮性和容错性。这有助于保证程序在面对异常情况时仍能够正常运行，并避免程序的崩溃。

## (35)Java Lambda表达式

### Lambda表达式
* Java Lambda表达式是Java 8中引入的一种新特性，它是一种简洁而强大的函数式编程的方式。
* 它允许您将函数作为参数传递给方法，或者使用函数式接口来创建函数对象。
* Lambda表达式可以被看作是一种匿名函数，可以在不创建类的情况下定义函数，因此它是一种更为简洁、灵活的编程方式。

### 函数式接口
* 函数式接口指在一个接口里面有且仅有一个抽象方法，但是可以有多个非抽象方法的接口。
* 在编写程序过程中可将@FunctionalInterface注解放在接口上方，如果接口是函数式接口则编译通过，不符合规范则编译报错。
* @FunctionalInterface注解会让编译器去检查编写的接口是否仅包含一个抽象方法。（所以不一定要写上）

### 使用Lambda表达式优点
* 简洁性：Lambda表达式比传统的Java代码更为简洁，可以减少大量样板式代码，使代码更易于阅读和理解。
* 灵活性：Lambda表达式可以在需要函数式接口的任何地方使用，从而提高了代码的灵活性。
* 并行处理：Lambda表达式可以简化并行处理代码的编写，可充分利用多核CPU的优势。
* Lambda表达式是Java 8中最强大和最具创新性的功能之一。

### 语法
* Lambda表达式的语法基本上由参数列表、箭头符号和方法体组成。
* 这个表达式中参数列表包含传递给方法的参数，箭头符号指示Lambda表达式的开始，而方法体则包含在大括号中的代码块。
```java
(parameter1, parameter2, ...) -> { expression }
```

## (36)Java Lambda表达式简写

### 省略参数类型
* 如果Lambda表达式的参数类型可以被编译器推断出来，那么可以省略参数类型。
```java
MyInterface myLambda = (a, b) -> a + b;
```

### 省略参数类型
* 局部变量类型推断
* Java 11开始支持在Lambda表达式中使用var关键字来定义变量。
* 使用var关键字可以让代码更加简洁，并且可以更容易地表达出变量的意图。
```java
MyInterface myLambda = (var a, var b) -> a + b;
```

### 省略参数括号
* 如果Lambda表达式只有一个参数，可以省略参数括号。
```java
MyInterface myLambda = a -> a * a;
```

### 省略方法体大括号
* 如果Lambda表达式方法体只有一行代码，可以省略方法体大括号。
```java
MyInterface myLambda = a -> a * a;
```

### 方法引用
* 如果Lambda表达式只是调用一个已经存在的方法，可以使用方法引用。
* 方法引用是一种特殊的Lambda表达式。方法引用使得代码更加简洁，易于阅读和维护。
* 方法引用可以看作是Lambda表达式的一个语法糖，它通过一些特定的符号和语法来指定要调用的方法。
```java
MyInterface myInterface = System.out::println;
```

### 方法引用形式
* 静态方法引用
  * 语法：ClassName::staticMethodName
  * 示例：System.out::println
  * 上面的代码使用了System.out对象的println方法，这个方法是一个静态方法，因此可以使用静态方法引用的语法糖。
* 实例方法引用
  * 语法：object::instanceMethodName
  * 示例：String::length
  * 上面的代码使用了String类的length方法，这个方法是一个实例方法，因此可以使用实例方法引用的语法糖。
* 对象方法引用
  * 语法：ClassName::instanceMethodName
  * 示例：ArrayList::size
  * 上面的代码使用了ArrayList类的size方法，这个方法是一个实例方法，但是它没有特定的实例对象，因此可以使用对象方法引用的语法糖。
* 构造方法引用
  * 语法：ClassName::new
  * 示例：String::new
  * 上面的代码使用了String类的构造方法，这个方法是一个构造方法，因此可以使用构造方法引用的语法糖。

## (37)Java 函数式接口

### 使用函数式接口的优点
* 简化代码：使用函数式接口和 Lambda 表达式可以使代码更加简洁，减少样板代码，降低代码复杂度。
* 提高可读性：使用函数式接口可以更加直观地表达代码的意图，使得代码更加易读易懂。
* 支持并行执行：函数式接口和 Lambda 表达式支持并行执行，可以将任务分配给多个线程同时执行，提高程序的并发能力和效率。
* 支持更灵活的设计模式：使用函数式接口可以更加灵活地设计代码结构，例如可以使用 Lambda 表达式作为参数传递，可以在运行时动态生成函数式接口的实现类等。
* 在函数式编程中，函数是头等对象即头等函数，这意味着一个函数，既可以作为其它函数的输入参数值，也可以从函数中返回值，被修改或者被分配给一个变量。

### Runnable
* Runnable 是一个没有参数和返回值的函数式接口，用于表示一个可执行的任务。
* 该接口只有一个抽象方法 run()，用于定义具体的任务代码或处理逻辑。
* 在多线程编程中，可以通过实现 Runnable 接口来创建一个新的线程。
```java
Runnable task = () -> System.out.println("Running the task");
new Thread(task).start();
```

### Consumer
* Consumer 是一个接收单个输入参数并且没有返回值的函数式接口。它表示了对输入参数的消费操作。
* 该接口只有一个抽象方法 accept(T t)，用于消费一个参数数据
* 该接口还有一个默认方法 andThen(Consumer<? super T> after)，可返回一个组合的 Consumer，依次执行操作。
```java
Consumer<String> consumer = System.out::println;
consumer.accept("Hello, World!");
```

### Supplier
* Supplier 是一个没有参数但是返回一个值的函数式接口。它表示了对值的生成操作。
* 该接口只有一个抽象方法 get()，用于按照由Lambda表达式定义的相关实现，返回一个具体的数据
```java
Supplier<Integer> randomInt = () -> new Random().nextInt(10);
int result = randomInt.get();
System.out.println(result); // 0 到 9 之间的随机整数
```

### Function
* Function 是一个接收一个参数并产生一个结果的函数式接口。它表示了从一个值到另一个值的映射操作。
* 该接口只有一个抽象方法 R apply(T t)，用于接收一个数据操作数据之后返回一个新的数据。
```java
Function<Integer, String> intToString = (i) -> "The number is " + i;
String result = intToString.apply(66);
System.out.println(result); // 输出 "The number is 66"
```

### Predicate
* Predicate 是一个接收单个输入参数并返回一个布尔值的函数式接口。它表示了对输入参数的判断操作。
* 该接口只有一个抽象方法 boolean test(T t)，用于对接受数据做出相应的判断。
```java
Predicate<Integer> isPositive = i -> i > 0;
boolean result1 = isPositive.test(42);
System.out.println(result1); // 输出 true
boolean result2 = isPositive.test(-1);
System.out.println(result2); // 输出 false
```

## (38)Java Lambda延迟执行

### Lambda延迟执行
* Java中Lambda表达式是不会立即执行的，而是在需要执行的时候才会被调用执行。
* 这种延迟执行的机制可以带来节省计算资源的优点：Lambda表达式只有在需要执行的时候才会被调用执行，因此可以减少不必要的计算资源消耗，提升性能。
* 但同时需要注意的是，Lambda表达式的延迟执行也可能带来一些负面影响，例如一些错误可能在运行时才被发现，因此需要在使用Lambda表达式时慎重考虑其优缺点。

## (39)Java 多线程

### 进程
* 进程是一个具有一定独立功能的程序在某个数据集合的一次运行活动，是系统进行资源分配和调度的一个独立单位。
* 从操作系统角度来看，可将进程分为系统进程和用户进程两类。
* 系统进程执行操作系统程序，完成操作系统的某些功能。
* 用户进程运行用户程序，直接为用户服务。
* 系统进程的优先级通常高于一般用户进程的优先级。
* 进程=(程序+数据+进程控制块PCB)。

### 程序与进程区别
* 进程是动态的：是程序的一次执行过程。
* 程序是静态的：是一组指令的有序集合。
* 进程是暂存的：在内存驻留。
* 程序是长存的：在存储介质中存储。

### 线程
* 80年代中期，随着操作系统理论和技术发展，提出了比进程更小的、能够独立运行的基本单位线程。
* 线程可以提高系统内程序并发执行的级别，可以进一步提高系统效率。
* 进程是资源拥有者，进程的创建撤销切换等过程中系统会付出较大的时空开销。
* 线程是进程中的一个实体，是处理器调度和分派的基本单位。
* 同时基本上不拥有系统资源，只拥有少量在运行中必不可少的资源，与同属进程共享进程全部资源。
* 同一个进程中的多个线程之间可以并发执行。
* 线程又称为轻量级进程(LWP)，传统的进程又称为重量级进程(HWP)。

### 线程的优点
* 创建新线程花费时间少，无需额外分配资源。
* 线程之间切换快。
* 线程间的通信，更便捷，更快。
* 线程可独立运行，能够充分利用和发挥CPU与外部设备的并行工作能力。

## (40)Java 线程创建

### 继承Thread类
* 可以定义一个继承Thread类的子类，在子类中重写run()方法，run()方法中的代码将在新的线程中执行。
* Thread类是Java多线程编程的核心类，提供了多种常用的方法:
* start()：启动线程，并执行线程中的run()方法。
* run()：定义线程的执行逻辑，必须被重写。
* sleep(long millis)：使当前线程暂停指定的时间（毫秒）。
* join()：等待线程执行完毕。
* join(long millis)：等待线程执行指定的时间（毫秒）。
* isAlive()：判断线程是否还存活。
* interrupt()：中断线程的执行。
* setPriority(int priority)：设置线程的优先级。
* getPriority()：获取线程的优先级。
* getName()：获取线程的名称。
* setName(String name)：设置线程的名称。
* yield()：让出CPU资源，使其他线程有机会执行。

### 实现Runnable接口
* 实现Runnable接口相较于继承Thread类：
* 实现 Runnable 接口相对于继承 Thread 类更加灵活。
* 因为 Java 是单继承的，如果继承了 Thread 类，就不能再继承其他的类。
* 但实现 Runnable 接口并不会对类的继承关系造成影响。
* 也更加符合面向对象的设计原则。
* 大多数情况下，使用多线程仅仅是为了实现某个功能，而不是继承 Thread 类的某些特性。

### 实现Callable接口
* Callable接口与Runnable接口类似，可用于多线程编程。
* 不同的是，Callable接口的call()方法可以返回一个值，并且可以抛出异常。
* 而 Runnable接口的run()方法是void 类型的，无法返回值或者抛出异常。

## (41)Java 线程状态
### 线程状态可分为
* NEW：线程刚被创建，但还没有被启动。
* RUNNABLE：线程正在执行或者等待执行，也就是有可能处于运行状态，或还在等待 CPU 时间片。
* BLOCKED：线程被阻塞不能执行，有可能正在等待获得一个监视器锁，。
* WAITING：线程正在等待另一个线程执行特定操作，例如调用 wait() 或者 join()等。
* TIMED_WAITING：线程正在等待另一个线程执行特定操作，但是等待时间有限，例如调用 sleep()等。
* TERMINATED：线程已经执行完毕。
* 一个线程在一个时间点只能处于一种状态。

### Java多线程状态的作用
* 实现线程同步：多线程状态中的 BLOCKED 和 WAITING 状态可以用来实现线程同步，从而避免多个线程访问共享资源时的并发问题。
* 监控线程状态：多线程状态可以用来监控线程的状态，从而了解线程的执行情况，及时进行调优和问题排查等等。

## (42)Java 线程中断

### 线程中断
* Java中，线程中断是一种协作机制，可允许一个线程中断另一个线程的执行。
* 线程中断并不是强制性的，它只是向目标线程发出了一个请求，希望目标线程能够自行停止执行。
* 目标线程可以根据自己的需要决定是否停止执行。

## (43)Java 守护线程
### 守护线程
* Java 中，守护线程（Daemon Thread）是一种特殊的线程。
* 它的作用是为其他线程提供服务，不会阻止 JVM 的退出。当所有的非守护线程结束时，守护线程会自动结束。

## (44)Java 线程同步

### 线程同步
* Java 线程同步是指在多个线程并发执行时，对共享资源进行协调和管理，以保证多线程间的数据访问正确性和一致性。
* Java 提供了多种同步机制，其中最常用的是JVM 实现的synchronized 关键字和JDK 实现的 ReentrantLock。

### synchronized关键字
* synchronized 关键字是 Java 中实现线程同步的一种方式。
* 它的作用是协调多个线程对共享资源的访问，以保证数据的正确性和一致性。
  * 保证原子性：synchronized 关键字可保证被它修饰的方法或代码块在同一时间只能被一个线程执行，从而避免了多个线程同时访问共享资源导致的数据不一致问题。
  * 保证可见性：synchronized 关键字不仅可以保证原子性，还可以保证多个线程对共享资源的修改在其他线程中是可见的。这是因为 synchronized 会将修改后的数据刷新到主内存中，而其他线程在访问共享资源时会从主内存中读取最新的数据。
  * 保证有序性：synchronized 关键字可以保证代码的执行顺序与程序中编写的顺序一致，即遵循了“先行发生原则”。这是因为 synchronized 在释放锁时会强制刷新线程的本地内存，从而使得之前的所有操作对其他线程都是可见的。

### 同步方法语法
* synchronized 方法会锁住整个对象，即使该对象有多个 synchronized 方法，其他线程也不能访问该对象的其他 synchronized 方法。
* 即同步方法中的锁对象是 this。
* 如果要对某个方法进行细粒度的控制，可以使用 synchronized 代码块。
```java
public synchronized void methodName() {
    // 方法体
}
```

### 同步代码块语法
* object 表示用来锁住代码块的对象，该对象可以是任何对象，但是需要保证多个线程访问该对象时使用的是同一个对象。
* 当某个线程进入该代码块时，它会锁住 object 对象，其他线程在访问该对象时需要等待当前线程释放锁。
* synchronized 代码块只会锁住被 synchronized 关键字修饰的代码块，其他代码不受影响。
* 如果要对整个方法进行控制，可以将 synchronized 关键字放在方法定义的位置。
```java
synchronized (object) {
    // 代码块
}
```

### ReentrantLock
* ReentrantLock 是 Java 中的一个可重入锁，它与 synchronized 关键字一样，都是用来实现线程同步的机制。
* ReentrantLock 与 synchronized 关键字相比，提供了更加灵活的线程同步控制。
* 作用：
  * 可以控制线程的等待时间：使用ReentrantLock可以调用tryLock(long time, TimeUnit unit)方法来控制线程等待获取锁的时间。如果等待时间超过了指定的时间，线程就会放弃获取锁，返回false，继续执行后续代码。
  * 可以实现公平锁：ReentrantLock提供了构造函数ReentrantLock(boolean fair)，用于指定锁是否是公平锁。公平锁是指多个线程获取锁的顺序与它们发出获取锁请求的顺序相同，即先来先服务。
  * 可以实现可重入锁：可重入锁是指同一个线程可以多次获取同一把锁，而不会被阻塞。ReentrantLock 就是一个可重入锁。
  * 可以实现条件变量：ReentrantLock 还提供了一个 Condition 接口，可以实现类似于 Object.wait() 和 Object.notify() 的功能，用于线程之间的通信和协调。
  * 可以实现精确控制锁的释放：相比于 synchronized 关键字，在使用 ReentrantLock 时，程序员可以更加精确地控制锁的释放时机，从而更好地控制线程同步。

### ReentrantLock
* 创建ReentrantLock对象。
```java
ReentrantLock lock = new ReentrantLock();
```
* 加锁
* 使用lock()方法可以获取锁对象，并且该方法是可重入的，也就是说，同一个线程可以多次调用该方法获取锁。
* 当多个线程同时访问加锁的代码块时，只有一个线程能够获取锁，其他线程需要等待锁被释放后才能进入代码块。
* 需要注意的是，加锁后一定要释放锁，否则会出现死锁的情况。
* 一般使用 try-finally 结构来确保锁被释放，即使在加锁过程中出现异常也能保证锁被释放。
```java
lock.lock();
try {
    // 需要线程同步的代码
} finally {
    lock.unlock();
}
```
* 解锁
* 使用unlock() 方法可以释放锁对象。
* ReentrantLock 还提供了一些高级的功能，如可重入锁、公平锁、限时等待等，可以通过构造函数或者相应的方法来实现。
```java
lock.unlock();
```

## (45)Java 线程wait与notify
### wait方法
* Java中的wait()方法是用于线程之间进行通信和同步的方法之一。
* 它使当前线程进入等待状态，直到另一个线程通知它可以继续执行。
* wait()方法必须在synchronized块内部调用，并且会释放该线程的锁，直到另一个线程调用notify()或notifyAll()方法为止。

### notify方法
* Java中的notify()方法是用于线程之间进行通信和同步的方法之一。
* 它用于通知等待的线程可以继续执行。
* notify()方法必须在synchronized块内部调用，并且只能唤醒等待该对象锁的一个线程，如果有多个线程等待该对象的锁，那么唤醒哪一个线程是不确定的。

## (46)Java 线程池

### 线程池
* 在Java中，线程池是一组预先创建的线程，这些线程可以被重复使用来执行多个任务。
* 使用线程池的好处是可以避免频繁地创建和销毁线程，从而提高程序的性能和效率。
* Java中的线程池通过Executor框架实现，可以使用`ThreadPoolExecutor`或  `ScheduledThreadPoolExecutor`类来创建线程池。
* `ThreadPoolExecutor`可以在程序启动时创建一定数量的线程，并且维护一个任务队列。当有新的任务到来时，线程池中的线程就会自动从任务队列中取出一个任务进行执行，当任务执行完毕后，线程又会自动返回线程池，等待下一个任务的到来。这样，线程的创建和销毁就大大减少了，同时也保证了并发任务的高效执行。
* `ScheduledThreadPoolExecutor`它继承`ThreadPoolExecutor`，可以按照一定的时间间隔定期执行任务，并且供了一些用于调度任务的方法如`schedule()`和`scheduleAtFixedRate()`。

## (47)Java ForkJoin

### ForkJoin
* ForkJoin是Java中用于实现并行计算的框架，它是一个线程池框架。
* 它通过将一个大任务拆分成若干个小任务，然后将这些小任务分配给不同的线程进行处理，最后将结果合并起来得到最终结果。

### RecursiveTask类：
* RecursiveTask是一个抽象类，它继承自ForkJoinTask类，并且实现了Future接口。它是ForkJoin框架中用于表示可以分解成更小任务的任务的基类之一。 RecursiveTask类compute()方法用于执行任务的实际计算。这个方法返回一个泛型类型的结果，表示这个任务的计算结果。 与普通的ForkJoinTask不同的是RecursiveTask在compute()方法中会递归地创建更小的子任务，并将它们提交给ForkJoinPool进行处理。在子任务的计算完成后，它们的结果会被合并起来得到最终的结果。
* 如果数组的大小小于等于阈值THRESHOLD，那么我们就对这个数组进行串行计算，否则就将数组拆分成两部分，分别创建两个ForkJoinExample对象，然后通过调用fork()方法将这两个对象提交给ForkJoinPool进行处理，并通过调用join()方法将它们的结果合并起来。

### ForkJoinPool类：
* ForkJoinPool是实现ForkJoin框架的线程池，它是一个ExecutorService的实现类。
* ForkJoinPool通过管理一组工作线程来执行ForkJoinTask。每个工作线程都维护了一个工作队列用于保存待执行的任务。当一个任务被提交给ForkJoinPool时，ForkJoinPool会选择一个工作线程来执行这个任务，如果这个任务还可以被分解成更小的子任务，那么这个线程就会将这个任务分解成多个子任务，并将它们加入到自己的工作队列中等待执行。
* 当一个工作线程的工作队列为空时，它会尝试从其他工作线程的工作队列中偷取一些任务来执行。这个偷取的过程被称为工作窃取算法"work-stealing"。这种机制可以保证ForkJoinPool中的所有线程都能够充分利用CPU资源，从而提高程序的性能。
* ForkJoinPool中可通过调用invoke()方法将一个任务提交给ForkJoinPool进行处理。当这个任务执行完成后，invoke()方法会返回这个任务的计算结果。
* 此外，ForkJoinPool还提供了一些方法，例如getParallelism()方法和getActiveThreadCount()方法，可以用于获取ForkJoinPool的一些状态信息。

## (48)Java 泛型

### 泛型
* Java中的泛型是一种在编译时期处理数据类型安全的机制。
* 它允许程序员在代码中定义一个通用的类、接口或方法，以便在实例化时可以指定具体的数据类型。
* 泛型的作用是增强代码的重用性和类型安全性。
* 使用泛型可以将数据类型的检查和转换从运行时移至编译时，从而可以在编译期就发现类型不匹配或错误的代码。
* 这样可以减少在运行时出现类型错误的可能性，提高代码的稳定性和可靠性。

### 泛型使用
* 泛型使用尖括号 <> 来定义类型参数，还可以使用通配符 ? 来表示不确定的类型。
* 通配符 ? 表示不确定的类型。这里可以添加null，因为其是一个特殊的类型，可以表示任何类型。

## (49)Java 反射

### 反射
* Java 反射（Reflection）是指在运行时动态地获取一个类的信息，并可以操作该类的属性、方法、构造函数等。
* 反射使得 Java 程序可以在运行时检查任意一个对象所属的类的属性和方法，并可以在运行时修改该类的属性和调用其方法，而不需要在编译期确定这些操作。
* 通过反射，可以访问类的私有属性和方法，甚至可以通过反射创建新的类实例。

### Java 反射提供了四个主要的类
* Class、Constructor、Field 和 Method。
* 其中，Class 类表示一个类或接口的运行时类型
* Constructor 类表示一个类的构造函数。
* Field 类提供有关类或接口的单个字段的信息，以及对它的动态访问权限。
* Method 类表示一个类的方法。

### 反射获取类信息的常用方法
* Class.getName()：获取类的名称。
* Class.getModifiers()：获取类的修饰符。
* Class.getSuperclass()：获取类的父类。
* Class.getInterfaces()：获取类实现的接口。
* Class.getConstructors()：获取类的所有公共构造函数。
* Class.getDeclaredConstructors()：获取类的所有构造函数（包括私有构造函数）。
* Class.getMethods()：获取类的所有公共方法。
* Class.getDeclaredMethods()：获取类的所有方法（包括私有方法）。
* Class.getFields()：获取类的所有公共属性。
* Class.getDeclaredFields()：获取类的所有属性（包括私有属性）。

### 反射基本步骤
1. 获取 Class 对象：可以通过 Class 类的 forName() 方法获取一个类的 Class 对象，也可以通过对象的 getClass() 方法获取一个对象的 Class 对象。还可以通过类名.class获取。
2. 获取构造函数：可以使用 Class 类的 getConstructor() 或 getDeclaredConstructor() 方法获取一个类的构造函数。
3. 设置或获取属性值：可以使用 Field 类的 set() 和 get() 方法设置或获取一个属性的值。
4. 获取方法：可以使用 Class 类的 getMethod() 或 getDeclaredMethod() 方法获取一个类的方法。
5. 调用方法：可以使用 Method 类的 invoke() 方法调用一个方法。

### 反射注意事项
* Java 反射是一个非常强大的工具，它可以让我们在运行时动态地获取和修改一个类的信息，创建对象，调用方法，获取和设置属性值等。
* 可以实现灵活的程序设计，尤其是在框架和插件式的应用程序中。但有些点需要注意：
* 避免滥用反射：反射虽然强大，但在大多数情况下必须使用反射的情况很少，反射会影响代码的性能和可读性。只有在必要的情况下才应该使用反射。
* 安全性问题：由于反射可以绕过访问修饰符的限制，因此在使用反射时需要特别小心。
* 性能问题：反射操作的性能比普通的方法调用要慢很多，因此在性能敏感的场合下应该尽量避免使用反射。

## (50)Java IO概念

### IO
* IO是**Input/Output的缩写，表示输入输出**。
* 在计算机编程中，**输入输出是程序与外部世界交互的方式**。
* 程序**通常需要读取外部数据并处理它**，然后将**处理结果输出到外部**。
* Java提供了一个**用于读写数据的标准库，称为Java IO**。
* 它提供了**一组类和接口**，可以**读写文件、网络流、内存流**等等。
* Java IO是**基于流（Stream）模型的**，它将数据看作是**一系列连续的字节流，从而进行读写操作**。
* Java IO在**处理IO操作时，是阻塞式的**，即**IO操作会一直阻塞直到数据完全读取或写入**。
* Java IO是Java中非常重要的一个部分，它提供了**许多类和接口来处理文件、网络和其他数据流**。
* 但除了Java IO之外，Java还**提供了NIO（New IO）和NIO2（New IO 2）两个新的IO API**，它们提供了**更加高效和灵活的IO操作方式**。
* 在选择Java IO或NIO时需要**根据具体的需求来选择适合的API**。对于一些**简单的IO操作**，可以使用Java IO，它的代码**简单易懂，适合快速开发**。
* 而对于一些**高并发、大数据量的IO操作**，应该**使用NIO或NIO2，它们提供了更高效的IO操作方式**。

### 流
* Java IO中最重要的概念之一是**流(Stream)**。
* 流是**一种数据传输方式，就像水流一样**。
* 数据从**源头(比如文件、网络)流向程序**，程序对数据**进行处理**，然后数据再从**程序流向目标(比如文件、网络)**。
* 流的作用是将**数据传输过来**，以便程序能够读取、处理、写出数据。
* Java中的流可按照数据单位的不同分为两种类型：**字节流和字符流**。
* Java中的流还可按照功能划分的不同分为两种类型：**节点流和处理流**。

#### 字节流
* 字节流用于**读写二进制数据**。字节流的**基本单位是字节(byte)**。
* Java中提供了两个基本的字节流：InputStream和OutputStream。
* InputStream：字节输入流，用于从**输入源中读取数据**。
* OutputStream：字节输出流，用于向**输出源中写入数据**。

#### 字符流
* 字符流用于**读写字符数据**。字符流的**基本单位是字符(char)**。
* Java中提供了两个基本的字符流：Reader和Writer。
* Reader：字符输入流，用于从**输入源中读取字符数据**。
* Writer：字符输出流，用于向**输出源中写入字符数据**。

#### 节点流
* 节点流：直接**与数据源相连的流，也称为低级流**。
* 节点流可以**从输入源中读取数据，或者向输出源中写入数据**。

#### 处理流
* 处理流：通过**对其他流进行包装，构建而成的流，也称为高级流**。
* 处理流**不能从输入源中读取数据**，或者向输出源中写入数据，它们只是**通过包装节点流的方式对其进行扩展或转换**。

### NIO
* NIO（New IO）则是**基于通道（Channel）和缓冲区（Buffer）的模型**。
* 通道是**双向**的，可以进行**读写操作**，而缓冲区则是用于**临时存储数据的区域**。
* NIO中的数据操作是**非阻塞的**，即**IO操作不会一直阻塞等待数据的到来或发送完成**。
* 当数据准备好时，通道会**通知程序进行数据的读取或写入**。
* 另外，NIO还**提供了选择器（Selector）机制**，可以让程序**同时处理多个通道的IO事件**。

### NIO2
* NIO2是JDK 7中**新引入的API**，它扩展了NIO API，提供了更多**便利的功能和更高级别的抽象**。
* **主要特性包括**：
  * 文件系统访问：NIO2**提供了Path和Files两个类**，用于**更方便地访问文件系统**。
  * 异步IO操作：NIO2提供了**异步IO操作的支持**，可以让程序更好地利用系统资源。
  * 改进的文件通道：NIO2**提供了FileChannel类的扩展，可以支持更多的操作，例如文件锁定、内存映射等**。
  * 改进的网络通道：NIO2**提供了AsynchronousSocketChannel和AsynchronousServerSocketChannel两个类**，可以支持**异步网络IO操作**。
 * NIO2的引入进一步**提高了Java在处理IO操作方面的能力**，使得Java在高并发、大数据量、异步IO等方面**更加灵活和强大**。

## (51)Java 文件IO

### 文件IO
* Java IO中的文件IO是指读写文件的操作。
* 在Java中，文件IO主要通过File、FileInputStream、FileOutputStream、FileReader和FileWriter等类实现。

#### File类
* File类用于表示文件和目录路径名的抽象表示。
* File类提供了多个构造方法，可以根据需要选择不同的构造方法来创建File对象。
* 常用的构造方法：
  * File(String pathname)：根据给定的路径名字符串创建一个新的File对象。路径可以是绝对路径或相对路径。
  * File(String parent, String child)：根据给定的父路径字符串和子路径字符串创建一个新的File对象。父路径可以是绝对路径或相对路径，子路径是相对于父路径的。
  * File(File parent, String child)：根据给定的父路径File对象和子路径字符串创建一个新的File对象。子路径是相对于父路径的。
```java
// 根据给定的路径名字符串创建File对象
File file1 = new File("C:\\example.txt");

// 根据给定的父路径和子路径字符串创建File对象
File file2 = new File("C:\\temp", "example.txt");

// 根据给定的父路径File对象和子路径字符串创建File对象
File parentDir = new File("C:\\temp");
File file3 = new File(parentDir, "example.txt");
```
* 它提供了一组方法，可以查询文件属性、创建和删除文件、以及遍历文件系统中的文件和目录等。
  * exists()：检查文件或目录是否存在。
  * isFile()：检查是否为文件。
  * isDirectory()：检查是否为目录。
  * getName()：获取文件或目录的名称。
  * getPath()：获取文件或目录的路径。
  * getAbsolutePath()：获取文件或目录的绝对路径。
  * getParent()：获取文件或目录的父目录路径。
  * list()：获取目录下的文件和子目录的名称数组。
  * listFiles()：获取目录下的文件和子目录的File对象数组。
  * mkdir()：创建目录。
  * mkdirs()：创建目录及其所有不存在的父目录。
  * delete()：删除文件或目录。
  * renameTo(File dest)：重命名文件或目录，将其移动到指定的目录下。

#### FileInputStream和FileOutputStream类
* ileInputStream和FileOutputStream是字节流，用于读取和写入文件。
* 它们的构造函数都需要传入File对象或文件路径名。

#### FileReader和FileWriter类
* FileReader和FileWriter是字符流，用于读取和写入文件。
* 它们的构造函数也需要传入File对象或文件路径名。

## (52)Java 缓冲流

### 缓冲流
* 在读写数据时，经常会发现IO操作非常耗时，这是因为每次读写操作都会涉及到磁盘或网络IO，而这种IO操作是非常慢的。
* 为了提高IO操作的效率，Java提供了缓冲流。
* 缓冲流是基于字节流和字符流之上的一层，是处理流的一种，它可以将数据缓存到内存中，减少实际IO操作的次数。
* 在读取数据时，缓冲流会预先读取一定量的数据到缓存中，当应用程序需要读取数据时，缓冲流会先从缓存中读取，如果缓存中没有数据了，就再去进行实际的IO操作。
* 在Java中，缓冲流有四种类型：
  * **BufferedInputStream**：字节缓冲输入流。
  * **BufferedOutputStream**：字节缓冲输出流。
  * **BufferedReader**：字符缓冲输入流。
  * **BufferedWriter**：字符缓冲输出流。

#### 缓冲字节流
* BufferedInputStream和BufferedOutputStream常用方法：
* 构造方法：
  * public BufferedInputStream(InputStream in): 创建一个新的缓冲输入流，以读取指定的输入流。
  * public BufferedOutputStream(OutputStream out): 创建一个新的缓冲输出流，以将数据写入指定的底层输出流。
* 读取数据和写入数据：
  * public int read() throws IOException: 从输入流中读取下一个字节数据。
  * public int read(byte[] b, int off, int len) throws IOException: 从输入流中读取一定量的字节，并将其存储在缓冲区数组 b 中。
  * public void write(int b) throws IOException: 将指定的字节写入此缓冲的输出流。
  * public void write(byte[] b, int off, int len) throws IOException: 将指定字节数组中从偏移量 off 开始的 len 个字节写入此缓冲输出流。
* 刷新缓存区：
  * public void flush() throws IOException: 刷新缓冲的输出流，强制将所有缓存的输出字节写入到底层输出流中。
* 关闭流：
  * public void close() throws IOException: 关闭缓冲的输入流或输出流，同时会关闭底层流。

#### 缓冲字符流
* BufferedReader和BufferedWriter常用方法
* 构造方法：
  * public BufferedReader(Reader in): 创建一个新的缓冲输入流，以读取指定的输入流。
  * public BufferedWriter(Writer out): 创建一个新的缓冲输出流，以将数据写入指定的底层输出流。
* 读取数据和写入数据：
  * public int read() throws IOException: 从输入流中读取一个字符。
  * public int read(char[] cbuf, int off, int len) throws IOException: 从输入流中读取一定量的字符，并将其存储在缓冲区数组 cbuf 中。
  * public void write(int c) throws IOException: 将指定的字符写入此缓冲的输出流。
  * public void write(char[] cbuf, int off, int len) throws IOException: 将指定字符数组中从偏移量 off 开始的 len 个字符写入此缓冲输出流。
* 刷新缓存区：
  * public void flush() throws IOException: 刷新缓冲的输出流，强制将所有缓存的输出字符写入到底层输出流中。
* 关闭流：
  * public void close() throws IOException: 关闭缓冲的输入流或输出流，同时会关闭底层流。

## (53)Java 对象流

### 对象流
* Java对象流是一种I/O流，可以用于读取和写入Java对象。
* 这些对象可以是任何Java类的实例，只要这些类实现了java.io.Serializable接口。

### 序列化和反序列化
* 序列化是将Java对象转换为字节序列的过程，这些字节序列可以在文件或网络连接中进行传输。
* 反序列化是将字节序列转换回Java对象的过程。
* ObjectOutputStream和ObjectInputStream可以用于将Java对象序列化为字节流并将其写入文件或网络连接，也可以将字节流反序列化为Java对象。
* 它们提供了一种方便的方式来持久化Java对象。

### Serializable接口
* 要使用对象流，Java类必须实现java.io.Serializable接口。
* Serializable接口是一个标记接口，它没有任何方法或字段，仅用于表示类可以被序列化。
* 在实现Serializable接口时，需要注意以下几点：
* 所有字段都必须是可序列化的。如果一个字段是一个对象，那么该对象的类也必须实现Serializable接口。
* transient关键字可以用于标记不希望序列化的字段。
* 如果一个类的父类没有实现Serializable接口，则需要确保父类的无参构造函数可以被调用。

### 序列化版本控制
* 在序列化和反序列化对象时，如果对象的类发生更改，则可能会发生版本控制问题。
* 例如，如果我们在Person类中添加了一个新字段，则在反序列化时导致不兼容，会出现异常。
* 为了解决这个问题，我们可以使用serialVersionUID。
* 每个可序列化的类都有一个serialVersionUID字段。
* 这样，当我们尝试反序列化旧版本的类时，JVM可以检查serialVersionUID并确定类是否与序列化的版本匹配。

### 避免序列化不必要的属性
* 在某些情况下，可能希望不序列化对象的某些属性。
* 例如，忽略某些敏感属性，以提高安全性。
* 在这种情况下，可以使用transient关键字修饰属性，从而防止它被序列化。

### 自定义序列化和反序列化
* 有时候，Java对象可能包含不支持序列化的属性或字段，或者我们希望控制序列化和反序列化过程。
* 在这种情况下，我们可以自定义序列化和反序列化过程。
* 自定义序列化的类需要继承Serializable接口，并添加相应的方法。
* 如：writeObject方法、readObject方法、readObjectNoData方法等。
* Serializable接口中没有任何成员，这些方法都是可选的并不强制要求，但一般需要定义前2个方法。

## (54)Java Socket


